<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天律界</title>
  
  <subtitle>精诚所至，金石为开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-21T14:07:43.915Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>天律界中子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>YUV420中的stride</title>
    <link href="http://yoursite.com/2018/08/21/stride-in-yuv420/"/>
    <id>http://yoursite.com/2018/08/21/stride-in-yuv420/</id>
    <published>2018-08-21T13:50:14.000Z</published>
    <updated>2018-08-21T14:07:43.915Z</updated>
    
    <content type="html"><![CDATA[<p>一幅图像除了宽度和高度，有时还有stride，详情参见<a href="https://docs.microsoft.com/zh-cn/windows/desktop/medfound/image-stride" target="_blank" rel="noopener">Image Stride</a>。对于RGB图像，stride很好理解。但是对于YUV图像，由于Y、U、V三个通道的宽度和排列方式不同，所以stride的样子不是很直观。最近我在工作时就遇到了这个问题。经过一番搜索，我在libyuv中找到了答案。下面就分享我找到的YUV420中的stride的答案。</p><p>YUV420一般分为四种格式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> I420</span><br><span class="line"></span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   U U U U U U U U</span><br><span class="line">   V V V V V V V V</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> YV12</span><br><span class="line"></span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   V V V V V V V V</span><br><span class="line">   U U U U U U U U</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> NV12</span><br><span class="line"></span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   U V U V U V U V</span><br><span class="line">   U V U V U V U V</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> NV21</span><br><span class="line"></span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   Y Y Y Y Y Y Y Y</span><br><span class="line">   V U V U V U V U</span><br><span class="line">   V U V U V U V U</span><br></pre></td></tr></table></figure></p><p>可以看到，所有四种格式的Y通道排列是相同的。对于I420和YV12格式而言，它们的U和V通道都是分开排列的，所以这两种格式称为平面格式，即YUV420p（p，即planar）。而对于NV12和NV21格式而言，它们的U和V通道是交错排列的，所以这两种格式称为半平面格式，即YUV420sp（sp，即semi-planar）。</p><p>由于平面格式和半平面格式排列的不一致，stride的表现也就不一致。下面我就平面格式和半平面格式各举一例，来说明它们的stride的样子。以“-”表示由于stride大于图像宽度而添加的额外的空白像素。需要注意的是，没有“Y”、”U”、”V”或“-”的地方不代表任何像素。即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Y Y - -</span><br><span class="line">Y Y - -</span><br><span class="line">U -</span><br><span class="line">V -</span><br></pre></td></tr></table></figure></p><p>在内存中的实际排列为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y Y - - Y Y - - U - V -</span><br></pre></td></tr></table></figure></p><ol><li><p>I420</p><p>平面格式有：Y stride，U stride和V stride。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">图像宽度：<span class="number">8</span></span><br><span class="line">图像高度：<span class="number">4</span></span><br><span class="line">Y stride: <span class="number">16</span></span><br><span class="line">U stride: <span class="number">6</span></span><br><span class="line">V stride: <span class="number">8</span></span><br><span class="line">Y Y Y Y Y Y Y Y - - - - - - - -</span><br><span class="line">Y Y Y Y Y Y Y Y - - - - - - - -</span><br><span class="line">Y Y Y Y Y Y Y Y - - - - - - - -</span><br><span class="line">Y Y Y Y Y Y Y Y - - - - - - - -</span><br><span class="line">U U U U - - U U U U - -</span><br><span class="line">V V V V - - - - V V V V - - - -</span><br></pre></td></tr></table></figure></li><li><p>NV12</p><p>半平面格式有：Y stride，UV stride。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">图像宽度：<span class="number">8</span></span><br><span class="line">图像高度：<span class="number">4</span></span><br><span class="line">Y stride: <span class="number">16</span></span><br><span class="line">UV stride: <span class="number">12</span></span><br><span class="line">Y Y Y Y Y Y Y Y - - - - - - - -</span><br><span class="line">Y Y Y Y Y Y Y Y - - - - - - - -</span><br><span class="line">Y Y Y Y Y Y Y Y - - - - - - - -</span><br><span class="line">Y Y Y Y Y Y Y Y - - - - - - - -</span><br><span class="line">U V U V U V U V - - - -</span><br><span class="line">U V U V U V U V - - - -</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一幅图像除了宽度和高度，有时还有stride，详情参见&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/desktop/medfound/image-stride&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="image-processing" scheme="http://yoursite.com/tags/image-processing/"/>
    
      <category term="YUV" scheme="http://yoursite.com/tags/YUV/"/>
    
      <category term="stride" scheme="http://yoursite.com/tags/stride/"/>
    
  </entry>
  
  <entry>
    <title>一个小技巧使OpenCL不影响渲染</title>
    <link href="http://yoursite.com/2018/07/21/opencl-trick-do-not-influence-render/"/>
    <id>http://yoursite.com/2018/07/21/opencl-trick-do-not-influence-render/</id>
    <published>2018-07-21T15:02:35.000Z</published>
    <updated>2018-07-21T15:35:10.419Z</updated>
    
    <content type="html"><![CDATA[<p>为了缩短算法在移动端的执行时间，有时我们会使用OpenCL来进行加速。OpenCL是基于命令队列的，也就是在主机端将所有要执行的命令放入队列，在设备端从队列中取出命令并执行。多数情况下，将命令放入队列只消耗极少的时间。这样一来，设备端就堆积了大量的命令需要执行，然后就会疯狂地消耗GPU资源，使得GPU资源被100%占用，造成的后果就是某些需要使用GPU进行渲染的程序严重卡顿，例如相机预览。</p><p>经过试验，我找到了一种简单的减少GPU资源占用，保证手机渲染不受影响的方法。以相机预览为例，它的刷新频率大约要保持在24Hz，那么我们就要保证在每41.7ms的时间里，其都能抢占到GPU资源进行渲染。那么我们只要保证两点就可以不影响其渲染：</p><ol><li>OpenCL每个kernel的执行时间都小于41.7ms(推荐小于30ms)；</li><li>在每41.7ms内，至少执行一次<code>clFinish()</code>来给予其抢占GPU资源的机会(对，技巧就是加<code>clFinish()</code>)。</li></ol><p>可以预见的是，由于不再占用100%的GPU资源，算法的执行时间会比原来要长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了缩短算法在移动端的执行时间，有时我们会使用OpenCL来进行加速。OpenCL是基于命令队列的，也就是在主机端将所有要执行的命令放入队列，在设备端从队列中取出命令并执行。多数情况下，将命令放入队列只消耗极少的时间。这样一来，设备端就堆积了大量的命令需要执行，然后就会疯狂
      
    
    </summary>
    
      <category term="OpenCL" scheme="http://yoursite.com/categories/OpenCL/"/>
    
    
      <category term="OpenCL" scheme="http://yoursite.com/tags/OpenCL/"/>
    
      <category term="trick" scheme="http://yoursite.com/tags/trick/"/>
    
      <category term="GPU" scheme="http://yoursite.com/tags/GPU/"/>
    
      <category term="render" scheme="http://yoursite.com/tags/render/"/>
    
  </entry>
  
  <entry>
    <title>使用Guided Filter去除彩色噪声</title>
    <link href="http://yoursite.com/2018/07/19/chroma-noise-reduction-with-guided-filter/"/>
    <id>http://yoursite.com/2018/07/19/chroma-noise-reduction-with-guided-filter/</id>
    <published>2018-07-19T15:56:27.000Z</published>
    <updated>2018-07-21T14:55:11.444Z</updated>
    
    <content type="html"><![CDATA[<p>手机在暗光环境下拍照时，由于进光量不足，拍出的照片上经常会出现严重的彩色噪声，如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/chroma-noise-reduction-with-guided-filter-2.jpg" alt="彩色噪声严重的图像" title="">                </div>                <div class="image-caption">彩色噪声严重的图像</div>            </figure></p><p>这种彩色噪声极大地影响了图像的观感，所以必须去除。而要在手机上运行，算法也一定要轻量化。这里提出一种轻量级而且比较实用的去彩噪的方法：使用Guided Filter去噪。</p><p>算法的步骤如下：</p><ol><li>将需要去噪的RGB图像(记为I)转换为YUV格式，记为I_YUV；</li><li>对I进行guided filter，I自己作为引导图像，得到滤波后的图像，记为I_gf；</li><li>将I_gf转换为YUV格式，记为I_gf_YUV；</li><li>使用I_YUV的Y通道替换I_gf_YUV的Y通道，得到新的YUV图像，记为I_Y_gf_UV;</li><li>将I_Y_gf_UV转换为RGB格式，即为去噪后图像。</li></ol><p>去噪后的效果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/chroma-noise-reduction-with-guided-filter-result.jpg" alt="去除彩色噪声后的图像" title="">                </div>                <div class="image-caption">去除彩色噪声后的图像</div>            </figure><br>可以看到，除了颜色有一点冲淡外，去彩噪的效果相当显著。</p><p>测试代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Win10 + Visual Studio Community 2017 + OpenCV 3.3.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/ximgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chromaNoiseReduction</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; src, cv::Mat&amp; dst, <span class="keyword">int</span> radius = <span class="number">30</span>, <span class="keyword">double</span> eps = <span class="number">0.03</span> * <span class="number">255</span> * <span class="number">255</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CV_Assert(src.type() == CV_8UC3);</span><br><span class="line">CV_Assert(src.cols % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; src.rows % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cv::Mat&amp; I = src;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1. convert I to YUV format</span></span><br><span class="line">cv::Mat I_YUV;</span><br><span class="line">cv::cvtColor(I, I_YUV, cv::COLOR_BGR2YUV_I420);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2. do guided filtering on I</span></span><br><span class="line">cv::Mat I_gf;</span><br><span class="line">cv::ximgproc::guidedFilter(I, I, I_gf, radius, eps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. convert I_gf to YUV format</span></span><br><span class="line">cv::Mat I_gf_YUV;</span><br><span class="line">cv::cvtColor(I_gf, I_gf_YUV, cv::COLOR_BGR2YUV_I420);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 4. replace I_gf_YUV's Y channel with I_YUV's Y channel</span></span><br><span class="line">cv::Mat I_Y_gf_UV = I_gf_YUV.clone();</span><br><span class="line"><span class="built_in">memcpy</span>(I_Y_gf_UV.data, I_YUV.data, I.cols * I.rows);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 5. convert I_Y_gf_UV to BGR, which is the result</span></span><br><span class="line">cv::cvtColor(I_Y_gf_UV, dst, cv::COLOR_YUV2BGR_I420);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat image = cv::imread(<span class="string">"2.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (image.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't open file."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::Mat result;</span><br><span class="line">chromaNoiseReduction(image, result);</span><br><span class="line"></span><br><span class="line">cv::imwrite(<span class="string">"result.jpg"</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;手机在暗光环境下拍照时，由于进光量不足，拍出的照片上经常会出现严重的彩色噪声，如下图所示：&lt;br&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
               
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="image-processing" scheme="http://yoursite.com/tags/image-processing/"/>
    
      <category term="denoise" scheme="http://yoursite.com/tags/denoise/"/>
    
      <category term="chroma noise" scheme="http://yoursite.com/tags/chroma-noise/"/>
    
      <category term="guided filter" scheme="http://yoursite.com/tags/guided-filter/"/>
    
  </entry>
  
  <entry>
    <title>分段问题的算法实现</title>
    <link href="http://yoursite.com/2018/07/19/segment-algorithm/"/>
    <id>http://yoursite.com/2018/07/19/segment-algorithm/</id>
    <published>2018-07-19T15:06:29.000Z</published>
    <updated>2018-07-19T15:09:14.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分段问题"><a href="#分段问题" class="headerlink" title="分段问题"></a>分段问题</h2><p>有一个长度为L的数组，其每个元素的索引分别是0，1，2，…，L-1。现欲将其分段，每段的长度为S(S &lt;= L)。求所有段的起始位置的索引。</p><p>例如，L为8，S为4时，输出：0，4。</p><p>当L不能被S整除时，一般会有如下三种选择：</p><ol><li>独立。即不能被整除的部分作为独立的一段。例如，L为9，S为4时，输出：0，4，8。</li><li>合并。即不能被整除的部分合并到上一段。例如：L为9，S为4时，输出：0，4。</li><li>分条件独立。即当满足一定条件时，不能被整除的部分作为独立的一段，否则合并到上一段。在本文中，我们只考虑一种条件：不能被整除的部分大于S的一半。例如，L为9，S为4时，输出：0，4；而L为11，S为4时，输出：0，4，8。</li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="独立"><a href="#独立" class="headerlink" title="独立"></a>独立</h3><p>最直接的实现，就是预先求出所分的段数，然后计算索引：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> S, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L % S == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count = L / S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">count = L / S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(i * S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，也可以使用迭代的方式，更加简洁：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> S, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; L; index += S)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>同样可以使用两种方式实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> S, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> count = L / S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(i * S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> S, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt;= L - S; index += S)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分条件独立"><a href="#分条件独立" class="headerlink" title="分条件独立"></a>分条件独立</h3><p>同样可以使用两种方式实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> S, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L % S == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count = L / S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">count = L / S;</span><br><span class="line"><span class="keyword">if</span> (L - count * S &gt; S / <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(i * S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment2</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> S, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; L - S / <span class="number">2</span>; index += S)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，用迭代的方式，代码更加简洁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分段问题&quot;&gt;&lt;a href=&quot;#分段问题&quot; class=&quot;headerlink&quot; title=&quot;分段问题&quot;&gt;&lt;/a&gt;分段问题&lt;/h2&gt;&lt;p&gt;有一个长度为L的数组，其每个元素的索引分别是0，1，2，…，L-1。现欲将其分段，每段的长度为S(S &amp;lt;= L)。求所
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="segment" scheme="http://yoursite.com/tags/segment/"/>
    
  </entry>
  
  <entry>
    <title>基于快速去雾的图像亮度增强方法</title>
    <link href="http://yoursite.com/2018/06/09/image-brightness-enhancement-based-on-haze-removal/"/>
    <id>http://yoursite.com/2018/06/09/image-brightness-enhancement-based-on-haze-removal/</id>
    <published>2018-06-09T13:37:09.000Z</published>
    <updated>2018-06-09T15:04:32.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在做一个图像处理的算法，因为图像太暗，所以需要对图像的亮度进行增强(不考虑噪声的放大)。尝试了网上搜索到的各种方法后，发现它们存在两个问题：容易造成原本较亮的地方过曝，并且参数不好设置。尝试了一些暗光增强的paper的算法后，发现它们又太慢了。这时我想到曾经看过的一篇paper说过，有一种亮度增强的算法是基于去雾来做的，步骤很简单：</p><ol><li>将RGB图像取反(关于图像取反，请参考我的这篇博客<a href="http://xuzhongzhang.cn/2018/06/07/opencv-image-invert/" target="_blank" rel="noopener">OpenCV图像取反</a>)；</li><li>对取反后的图像进行去雾；</li><li>将去雾后的图像取反。</li></ol><p>其背后的理念是：暗光图像取反后，原本接近黑色的像素就会变成接近白色，整张图像就会类似于有雾的图像。于是对这样的图像进行去雾后，白色的像素就变暗了，再反色后，像素就变亮了！没毛病！</p><h2 id="快速去雾算法"><a href="#快速去雾算法" class="headerlink" title="快速去雾算法"></a>快速去雾算法</h2><p>说起去雾，恐怕大多数人的第一反应就是鼎鼎大名的何恺明博士的暗通道先验去雾算法。我的第一反应也是这个。但是在了解之后，我发现这种方法速度太慢了，难以应用到我的算法中。于是我开始搜索快速的去雾算法，很快找到了这篇论文<a href="https://wenku.baidu.com/view/63e8cf1e10661ed9ad51f3ea.html" target="_blank" rel="noopener">《基于单幅图像的快速去雾算法》刘倩, 陈茂银, 周东华</a>(这篇文章中也提到了暗通道先验去雾算法的速度太慢)，速度很快，只有O(1)复杂度。</p><p>这篇论文我并没有仔细看，而是秉承“拿来主义”的精神，直接根据论文提供的算法流程实现了代码。原因是它的算法流程太简单了，在轻松地实现了代码之后，就没有再看的欲望了~这里贴一下它的算法流程，你们自己看：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/image-brightness-enhancement-based-on-haze-removal-algorithm.png" alt="算法流程" title="">                </div>                <div class="image-caption">算法流程</div>            </figure></p><h2 id="源码解释"><a href="#源码解释" class="headerlink" title="源码解释"></a>源码解释</h2><p>我把实现的代码放到了GitHub：<a href="https://github.com/rzwm/IBEABFHR" target="_blank" rel="noopener">IBEABFHR</a>(原谅我这个取名废)，请点进去看效果图，我这里就不重复放了。我感觉效果还是很好的，暗处的亮度增强得很好，亮处虽然有过曝，但并不是很明显。而且控制亮度的参数很好调整，只要随便找一张图像调整好参数，就可以应用于所有图片了。</p><h3 id="运行速度"><a href="#运行速度" class="headerlink" title="运行速度"></a>运行速度</h3><p>代码是用OpenCV实现的，同时支持彩色图像和灰度图像。在我的电脑上(CPU: E3-1230 v3)测试，运行100次取平均值，速度如下：</p><table><thead><tr><th>分辨率</th><th>类型</th><th>时间</th></tr></thead><tbody><tr><td>1024x768</td><td>灰度图像</td><td>8.77ms</td></tr><tr><td>1024x768</td><td>彩色图像</td><td>16.24ms</td></tr><tr><td>1920x1080</td><td>灰度图像</td><td>22.61ms</td></tr><tr><td>1920x1080</td><td>彩色图像</td><td>40.60ms</td></tr><tr><td>4160x2340</td><td>灰度图像</td><td>104.57ms</td></tr><tr><td>4160x2340</td><td>彩色图像</td><td>186.14ms</td></tr></tbody></table><p>但是如果你只使用我的算法一次，可能速度要慢得多，原因是第一次取反操作因为未知原因耗费了额外的时间。关于这点，请参看我的这篇博客<a href="http://xuzhongzhang.cn/2018/06/07/opencv-image-invert/" target="_blank" rel="noopener">OpenCV图像取反</a>。</p><h3 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h3><p>这个算法总共有两个可变参数。一个是在step 3中进行均值滤波时的所用的滤波半径<code>radius</code>，另一个是在step 5中用的<code>ρ</code>。</p><p><code>radius</code>参数在某些图像上可以控制对比度，数值越大，对比度越强，但在某些图像上不起作用。这个参数取值不能太小，否则增强后的图像会出现光晕。一般不应小于50或者图像宽度和高度最大值的的1/20。</p><p><code>ρ</code>控制图像增强的亮度，数值越大，增强后的图像越亮。一般的取值范围为[1.0, 2.0]。在我的实现中，我使用了一种简单选择的策略，请参看源代码，仅供参考。</p><p>关于参数的效果及设置，我参考了这篇博客<a href="https://www.cnblogs.com/Imageshop/p/3410279.html" target="_blank" rel="noopener">一种可实时处理 O(1)复杂度图像去雾算法的实现</a>，在此进行感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;最近在做一个图像处理的算法，因为图像太暗，所以需要对图像的亮度进行增强(不考虑噪声的放大)。尝试了网上搜索到的各种方法后，发现它们存在两个问
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="image-processing" scheme="http://yoursite.com/tags/image-processing/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV两个Mat相减的隐藏秘密</title>
    <link href="http://yoursite.com/2018/06/08/opencv-abs-vs-absdiff/"/>
    <id>http://yoursite.com/2018/06/08/opencv-abs-vs-absdiff/</id>
    <published>2018-06-08T15:01:32.000Z</published>
    <updated>2018-06-08T16:04:12.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天在看同事写的代码时，发现一个“错误”：<br>他的原意是实现以下功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat absDiff;</span><br><span class="line">cv::absdiff(mat1, mat2, absDiff);</span><br></pre></td></tr></table></figure><p>其中<code>mat1</code>和<code>mat2</code>均为<code>CV_8UC1</code>类型。</p><p>但是可能是一时没想起这个函数，于是他写成了这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat absDiff = cv::<span class="built_in">abs</span>(mat1 - mat2);</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>于是我认真地告诉他，这样做是错的。假设<code>mat1</code>为<code>[0]</code>，<code>mat2</code>为<code>[255]</code>，那么<code>mat1 - mat2</code>将会得到<code>[0]</code>，因为<code>cv::saturate_cast&lt;uchar&gt;(0 - 255) == 0</code>。则<code>cv::abs([0])</code>自然就是<code>[0]</code>，而他的期望是得到<code>[255]</code>。</p><p>并且我写出如下代码证明他是错的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat diff = mat1 - mat;</span><br></pre></td></tr></table></figure><p>结果<code>diff</code>确实是<code>[0]</code>。那么<code>cv::Mat absDiff = cv::abs(diff);</code>肯定就是<code>[0]</code>了。</p><p>但是他坚持让我用<code>cv::Mat absDiff = cv::abs(mat1 - mat2);</code>测试。结果。。。。<code>absDiff</code>竟然真的是<code>[255]</code>！我当时就震惊了，同时隐隐有一种感觉：这其中一定隐藏着一个天大的秘密。</p><h2 id="秘密"><a href="#秘密" class="headerlink" title="秘密"></a>秘密</h2><p>于是我进入调试模式，认真观察每一步，终于明白了玄机所在。</p><h3 id="为什么我得到了-0"><a href="#为什么我得到了-0" class="headerlink" title="为什么我得到了[0]"></a>为什么我得到了<code>[0]</code></h3><p>先来分析我的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat diff = mat1 - mat;</span><br></pre></td></tr></table></figure><p>在我以前的观念里，<code>mat1 - mat</code>是两个<code>cv::Mat</code>互相作用，实际上调用的是<code>cv::subtract()</code>。但是事实上，<code>mat1 - mat2</code>调用的是以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CV_EXPORTS MatExpr <span class="keyword">operator</span> - (<span class="keyword">const</span> Mat&amp; a, <span class="keyword">const</span> Mat&amp; b);</span><br><span class="line"></span><br><span class="line">MatExpr <span class="keyword">operator</span> - (<span class="keyword">const</span> Mat&amp; a, <span class="keyword">const</span> Mat&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    MatExpr e;</span><br><span class="line">    MatOp_AddEx::makeExpr(e, a, b, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>mat1 - mat2</code>实际上是生成了一个<code>MatExpr</code>对象。在生成过程中，并没有进行实际的相减操作，而只是保存了<code>a</code>和<code>b</code>，并记录了它们之间期望进行的操作：相减。实际的相减操作是在类型转换时进行的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cv::Mat diff = mat1 - mat; // 在这里调用了operator Mat()</span></span><br><span class="line"></span><br><span class="line">MatExpr::<span class="function"><span class="keyword">operator</span> <span class="title">Mat</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat m;</span><br><span class="line">    op-&gt;assign(*<span class="keyword">this</span>, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>assign</code>中最终调用了<code>cv::subtract()</code>。所以<code>mat1 - mat2</code>得到了<code>[0]</code>。</p><h3 id="为什么同事得到了-255"><a href="#为什么同事得到了-255" class="headerlink" title="为什么同事得到了[255]"></a>为什么同事得到了<code>[255]</code></h3><p>再来分析我同事的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat absDiff = cv::<span class="built_in">abs</span>(mat1 - mat2);</span><br></pre></td></tr></table></figure><p>从上面我们知道，<code>mat1 - mat2</code>生成了一个<code>MatExpr</code>对象。而<code>cv::abs()</code>调用的是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatExpr <span class="title">abs</span><span class="params">(<span class="keyword">const</span> MatExpr&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CV_INSTRUMENT_REGION()</span><br><span class="line"></span><br><span class="line">    MatExpr en;</span><br><span class="line">    e.op-&gt;<span class="built_in">abs</span>(e, en);</span><br><span class="line">    <span class="keyword">return</span> en;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数再次生成了一个<code>MatExpr</code>对象，其中记录了操作对象<code>e</code>和期望进行的操作：取绝对值，而并没有进行实际的运算。然后同上面一样，它是在赋值给<code>absDiff</code>时调用<code>operator Mat()</code>进行运算的。神奇的地方来了，它把前面的相减操作与这里的取绝对值操作组合到了一起(而不是依次运算)，最终调用的正是<code>cv::absdiff()</code>！</p><p>于是谜底揭开了，一切的原因都是因为<code>MatExpr</code>这个中间对象实现了延迟运算和操作组合。</p><h2 id="感叹"><a href="#感叹" class="headerlink" title="感叹"></a>感叹</h2><p>我还是太年轻！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;今天在看同事写的代码时，发现一个“错误”：&lt;br&gt;他的原意是实现以下功能：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="OpenCV" scheme="http://yoursite.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCL优化小技巧：预创建所有Kernel</title>
    <link href="http://yoursite.com/2018/06/07/opencl-trick-precreate-all-kernels/"/>
    <id>http://yoursite.com/2018/06/07/opencl-trick-precreate-all-kernels/</id>
    <published>2018-06-07T15:48:43.000Z</published>
    <updated>2018-06-07T16:10:59.518Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一些图像处理的算法，跑在高通的开发板上，其中使用了OpenCL进行加速。在此过程中，也总结了几个加速的小技巧。今天就来谈其中一个不太有用的小技巧：预创建所有Kernel。</p><p>第一次进行OpenCL加速时，我注意到，创建<code>cl_kernel</code>时，会耗费几毫秒到二十几毫秒的时间。如果算法中需要创建几十个<code>cl_kernel</code>，那花费的时间也有几百毫秒了。这让人很难接受。</p><p>后来我又注意到，对于同一个Kernel，只有第一次创建时才会花费那么多时间，后续再次创建(无论前面创建的是否已经释放掉)所花费的时间将会大大减少，几乎可以忽略不计。那么机会就来了：我们可以在初始化时预先创建好所有Kernel，再全部释放掉。然后在实际的处理算法中，和平时一样使用<code>clCreateKernel()</code>和<code>clReleaseKernel()</code>，同时也不用担心创建Kernel所花费的额外时间了。</p><p>为什么我说这个小技巧不太有用呢？因为只有使用源码，也就是<code>clCreateProgramWithSource()</code>创建program时，才会出现创建Kernel耗时严重的现象。而一般发布出来的算法都会使用二进制文件，也就是<code>clCreateProgramWithBinary()</code>，在保存为二进制时，一定已经先创建所有Kernel了，耗时问题也就不存在了。</p><p>但是在加速未完成之前，我们一般还是会直接使用源码来调试。此时预创建所有Kernel，可以排除掉创建Kernel的时间，使得对算法的最终运行时间估计更准确。所以，这个小技巧还是有一点用的:)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做了一些图像处理的算法，跑在高通的开发板上，其中使用了OpenCL进行加速。在此过程中，也总结了几个加速的小技巧。今天就来谈其中一个不太有用的小技巧：预创建所有Kernel。&lt;/p&gt;
&lt;p&gt;第一次进行OpenCL加速时，我注意到，创建&lt;code&gt;cl_kernel&lt;/c
      
    
    </summary>
    
      <category term="OpenCL" scheme="http://yoursite.com/categories/OpenCL/"/>
    
    
      <category term="OpenCL" scheme="http://yoursite.com/tags/OpenCL/"/>
    
      <category term="trick" scheme="http://yoursite.com/tags/trick/"/>
    
  </entry>
  
  <entry>
    <title>OpenCL clCreateBuffer占用太多时间</title>
    <link href="http://yoursite.com/2018/06/07/opencl-clcreatebuffer-takes-long-time/"/>
    <id>http://yoursite.com/2018/06/07/opencl-clcreatebuffer-takes-long-time/</id>
    <published>2018-06-07T15:36:14.000Z</published>
    <updated>2018-06-09T12:59:42.370Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个图像处理的算法，跑在高通平台上，需要使用OpenCL加速。代码分为三个部分：</p><ol><li>初始化</li><li>处理图像</li><li>释放资源</li></ol><p>为了尽可能地减少算法的运行时间，我将一切可以预处理的内容都放到了<strong>初始化</strong>中，其中就包括了创建buffer。在<strong>初始化</strong>中，我调用<code>clCreateBuffer()</code>创建了9个buffer，共计约占用600MB内存。然后在<strong>处理图像</strong>中重复使用这些buffer，最后在<strong>释放资源</strong>中释放所有buffer。</p><p>但是在实际测试后发现，每调用一次<code>clCreateBuffer()</code>，都会花费大约70ms的时间，这样一来，创建所有buffer就花费了约600ms的时间。同样地，在释放这些buffer时，每个也会花费几十毫秒的时间。如此，<strong>初始化</strong>和<strong>释放资源</strong>的时间就令人比较难以接受。</p><p>经同事提醒，我想到了高通文档《Qualcomm® Snapdragon™ Mobile Platform OpenCL General Programming and Optimization》中提到的ION内存。文档中说，使用ION可以避免内存拷贝。那么对缩短创建buffer的时间会不会也有帮助呢？毕竟在我的印象中，使用<code>new</code>创建一段几百MB的内存也才花费几毫秒的时间。</p><blockquote><p>使用ION内存来创建OpenCL buffer需要<code>cl_qcom_ion_host_ptr</code>扩展(在上述文档中有提到)，其说明及示例代码在OpenCL官网可以查到，为了方便，我直接贴到这里：<a href="https://www.khronos.org/registry/OpenCL/extensions/qcom/cl_qcom_ion_host_ptr.txt" target="_blank" rel="noopener">cl_qcom_ion_host_ptr</a>。</p></blockquote><p>然后我在高通平台上进行了测试。测试结果让人半忧半喜。令人忧的是，使用ION内存来创建OpenCL buffer时，<code>clCreateBuffer()</code>只需要零点几毫秒的时间，但是创建ION内存却需要使用数十毫秒的时间，等于创建buffer的时间转移到了创建ION内存上，最终花费的时间差别不大。令人喜的是，上述现象只发生在第一次调用<strong>初始化</strong>时。后面再次运行算法，再次调用<strong>初始化</strong>，创建buffer和创建ION内存的时间便会都变为零点几毫秒。另外，无论是第几次调用<strong>释放资源</strong>，速度都很快，总共只需要数毫秒。</p><p>所以问题并未彻底解决。</p><p>由于我对这个现象背后的原理知之不详，所以也只能做到这一步了。如果了解原理的话，是否可以真正地缩短创建OpenCL buffer的时间呢？</p><p>另外我还观察到一个现象。在不使用ION内存时，我使用高通的性能分析工具Snapdragon Profiler观察到，运行算法时系统内存会上升约700MB。但是使用ION内存时，系统内存只会上升200多MB。这可能也跟ION的原理有关吧。</p><p>如果有哪位朋友知道上述两个现象的原因，可以发邮件告诉我。多谢！</p><p>注：最后还是决定使用ION内存，因为看到高通的Camera相关代码中就使用了ION内存。并且使用ION内存后，算法实际运行时间未发生发化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做一个图像处理的算法，跑在高通平台上，需要使用OpenCL加速。代码分为三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;li&gt;处理图像&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了尽可能地减少算法的运行时间，我将一切可以预处理的内容都放到了&lt;
      
    
    </summary>
    
      <category term="OpenCL" scheme="http://yoursite.com/categories/OpenCL/"/>
    
    
      <category term="OpenCL" scheme="http://yoursite.com/tags/OpenCL/"/>
    
      <category term="trick" scheme="http://yoursite.com/tags/trick/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV图像取反</title>
    <link href="http://yoursite.com/2018/06/07/opencv-image-invert/"/>
    <id>http://yoursite.com/2018/06/07/opencv-image-invert/</id>
    <published>2018-06-07T13:24:10.000Z</published>
    <updated>2018-06-07T14:30:09.035Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个基于去雾的图像亮度增强的算法<a href="https://github.com/rzwm/IBEABFHR" target="_blank" rel="noopener">IBEABFHR</a>，其中用到了图像取反的操作。所谓图像取反，就是将RGB图像的每个像素点(r, g, b)，使用(255 - r, 255 - g, 255 - b)替换。对于灰度图像而言，则是将(g)使用(255 - g)替换。<br>如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/opencv-image-invert-rgb.jpg" alt="RGB图像" title="">                </div>                <div class="image-caption">RGB图像</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/opencv-image-invert-rgb_inverse.jpg" alt="RGB取反图像" title="">                </div>                <div class="image-caption">RGB取反图像</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/opencv-image-invert-gray.jpg" alt="灰度图像" title="">                </div>                <div class="image-caption">灰度图像</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/opencv-image-invert-gray_inverse.jpg" alt="灰度取反图像" title="">                </div>                <div class="image-caption">灰度取反图像</div>            </figure></p><p>在OpenCV中要实现此操作，可以遍历每个像素，用255去减，此方法不再赘述。更直接地，可以对图像(<code>cv::Mat</code>)整体做减法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat image = cv::imread(<span class="string">"rgb.jpg"</span>);</span><br><span class="line">cv::Mat image_inverse = cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) - image;</span><br></pre></td></tr></table></figure><p>也可以使用<code>cv::subtract</code>，效果是一样的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat image = cv::imread(<span class="string">"rgb.jpg"</span>);</span><br><span class="line">cv::Mat image_inverse;</span><br><span class="line">cv::subtract(cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), image, image_inverse);</span><br></pre></td></tr></table></figure><p>但是我在网上搜索到了更好的方法，那就是使用位运算中的取反操作(~)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat image = cv::imread(<span class="string">"rgb.jpg"</span>);</span><br><span class="line">cv::Mat image_inverse = ~image;</span><br></pre></td></tr></table></figure><p>原理是，对于一个<code>unsigned char</code>类型的变量<code>c</code>，<code>255 - c</code>与<code>~c</code>是相等的。</p><p>此方法在<code>opencv2\core\mat.hpp</code>中声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CV_EXPORTS MatExpr <span class="keyword">operator</span> ~(<span class="keyword">const</span> Mat&amp; m);</span><br></pre></td></tr></table></figure><p>需要注意的是，此方法仅对整数型的<code>cv::Mat</code>有效。</p><p>一般来说，位运算的速度都是比较快的，事实也是如此，我使用一张4160x2340的图像来做测试，两种方法各运算100次取平均时间，结果如下:</p><ul><li>相减法：14.1862ms</li><li>位运算法：11.8158ms</li></ul><p>但是在测试过程中发现一个问题：第一次取反操作(无论是相减法还是位运算法)竟然需要耗时100多毫秒，而后面再进行取反操作速度就变正常了，只要10几毫秒。现在还不知道原因是什么。希望有知道的朋友可以告诉我。可以发我邮箱。下面附上出现此问题的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Timer.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Timer()</span><br><span class="line">: t1(res::zero())</span><br><span class="line">, t2(res::zero())</span><br><span class="line">&#123;</span><br><span class="line">tic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Timer()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t1 = clock::now();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t2 = clock::now();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" time: "</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;res&gt;(t2 - t1).count() / <span class="number">1e3</span> &lt;&lt; <span class="string">"ms."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::high_resolution_clock clock;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::microseconds res;</span><br><span class="line"></span><br><span class="line">clock::time_point t1;</span><br><span class="line">clock::time_point t2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat image = cv::imread(<span class="string">"5.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (image.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't open file."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timer timer;</span><br><span class="line">timer.tic();</span><br><span class="line">cv::Mat temp = cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) - image;</span><br><span class="line">timer.toc(<span class="string">"single "</span>);</span><br><span class="line"></span><br><span class="line">timer.tic();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat temp1 = cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) - image;</span><br><span class="line">&#125;</span><br><span class="line">timer.toc(<span class="string">"subtract"</span>);</span><br><span class="line"></span><br><span class="line">timer.tic();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat temp1 = ~image;</span><br><span class="line">&#125;</span><br><span class="line">timer.toc(<span class="string">"operator~"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：本文使用OpenCV 3.3.0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做一个基于去雾的图像亮度增强的算法&lt;a href=&quot;https://github.com/rzwm/IBEABFHR&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IBEABFHR&lt;/a&gt;，其中用到了图像取反的操作。所谓图像取反，就是将RGB图像的每
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="OpenCV" scheme="http://yoursite.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>C++11高精度计时器</title>
    <link href="http://yoursite.com/2018/06/05/cpp-timer/"/>
    <id>http://yoursite.com/2018/06/05/cpp-timer/</id>
    <published>2018-06-05T14:26:41.000Z</published>
    <updated>2018-06-05T15:07:31.163Z</updated>
    
    <content type="html"><![CDATA[<p>做图像处理算法时，免不了要测量函数的运行时间。以前我都是使用OpenCV的计时函数<code>cv::getTickCount()</code>和<code>cv::getTickFrequency()</code>，但是这样一来，在不使用OpenCV的项目中就没法用了。幸好C++11增加了<code>std::chrono</code>库，可以很方便地实现跨平台的时间测量。于是我封装了一个简单的计时器类，这样只要将其简单地添加到项目中，就可以直接使用了。此计时器单位为毫秒，但可以精确到微秒级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Timer()</span><br><span class="line">: t1(res::zero())</span><br><span class="line">, t2(res::zero())</span><br><span class="line">&#123;</span><br><span class="line">tic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Timer()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t1 = clock::now();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t2 = clock::now();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" time: "</span> </span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;res&gt;(t2 - t1).count() / <span class="number">1e3</span> &lt;&lt; <span class="string">"ms."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::high_resolution_clock clock;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::microseconds res;</span><br><span class="line"></span><br><span class="line">clock::time_point t1;</span><br><span class="line">clock::time_point t2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Timer timer;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">timer.toc(<span class="string">"output 1"</span>);</span><br><span class="line"></span><br><span class="line">timer.tic();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">timer.toc(<span class="string">"output 2"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">output <span class="number">1</span> time: <span class="number">0.26</span>ms.</span><br><span class="line"><span class="number">2</span></span><br><span class="line">output <span class="number">2</span> time: <span class="number">0.039</span>ms.</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做图像处理算法时，免不了要测量函数的运行时间。以前我都是使用OpenCV的计时函数&lt;code&gt;cv::getTickCount()&lt;/code&gt;和&lt;code&gt;cv::getTickFrequency()&lt;/code&gt;，但是这样一来，在不使用OpenCV的项目中就没法用了。幸
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>提取图像细节的两种方法</title>
    <link href="http://yoursite.com/2018/04/29/two-ways-of-extracting-detail-of-image/"/>
    <id>http://yoursite.com/2018/04/29/two-ways-of-extracting-detail-of-image/</id>
    <published>2018-04-29T13:50:14.000Z</published>
    <updated>2018-06-05T15:25:29.169Z</updated>
    
    <content type="html"><![CDATA[<p>一幅图像可以分解为两层：底层(base layer)和细节层(detail layer)。底层包含图像的低频信息，反映了图像在大尺度上的强度变化；细节层包含图像的高频信息，反映了图像在小尺度上的细节。分解图像有两种方式，以下分别进行解释。</p><h2 id="1-加性分解"><a href="#1-加性分解" class="headerlink" title="1. 加性分解"></a>1. 加性分解</h2><p>要获取图像的底层，即图像的低频信息，使用低通滤波(如均值滤波(mean filter)，高斯滤波(gaussian filter)，导向滤波(guided filter))对图像进行滤波即可：<br>$$B = f(I) $$<br>其中$I$表示要分解的图像，$f(\cdot)$表示低通滤波操作，$B$为提取的底层。</p><p>提取底层后，使用源图像减去底层，即为细节层：<br>$$D = I - B$$<br>其中$D$表示提取的细节层。</p><p>因为底层加上细节层即为源图像，所以我称此种分解方法为加性分解，对应于加性噪声。关于此种方法的应用，可以参见[1]。</p><h2 id="2-乘性分解"><a href="#2-乘性分解" class="headerlink" title="2. 乘性分解"></a>2. 乘性分解</h2><p>获取底层的方法与<strong>加性分解</strong>相同。然后使用源图像除以底层，即可得到细节层：<br>$$D = \frac{I + \epsilon}{B + \epsilon}$$<br>其中$\epsilon$为一个很小的常数，以防止除零错误。</p><p>因为底层乘以细节层即为源图像，所以我称此种分解方法为乘性分解，对应于乘性噪声。关于此种方法的应用，可以参见[2]。在其他文章中，此处得到的细节层也称为商图像(quotient image)[3]或比例图像(ratio image)[4]。</p><h2 id="3-代码及效果"><a href="#3-代码及效果" class="headerlink" title="3. 代码及效果"></a>3. 代码及效果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图像细节提取。</span></span><br><span class="line"><span class="comment">// 编程环境：Visual Studio Community 2015 + OpenCV 3.3.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat I = cv::imread(<span class="string">"im.png"</span>);</span><br><span class="line"><span class="keyword">if</span> (I.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">I.convertTo(I, CV_32FC3);</span><br><span class="line"></span><br><span class="line">cv::Mat B;</span><br><span class="line">cv::boxFilter(I, B, <span class="number">-1</span>, cv::Size(<span class="number">31</span>, <span class="number">31</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 加性分解</span></span><br><span class="line">cv::Mat D1 = I - B;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 乘性分解</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> epsilon = <span class="number">1.0f</span>;</span><br><span class="line">cv::Mat D2 = (I + epsilon) / (B + epsilon);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示图像</span></span><br><span class="line">I.convertTo(I, CV_8UC3);</span><br><span class="line">cv::imshow(<span class="string">"源图像"</span>, I);</span><br><span class="line"></span><br><span class="line">B.convertTo(B, CV_8UC3);</span><br><span class="line">cv::imshow(<span class="string">"Base layer"</span>, B);</span><br><span class="line"></span><br><span class="line">D1 = cv::<span class="built_in">abs</span>(D1); <span class="comment">// 因为包含负数，所以取绝对值</span></span><br><span class="line">D1.convertTo(D1, CV_8UC3);</span><br><span class="line">cv::imshow(<span class="string">"Detail layer 1"</span>, D1);</span><br><span class="line"></span><br><span class="line">cv::normalize(D2, D2, <span class="number">0.0</span>, <span class="number">255.0</span>, cv::NORM_MINMAX); <span class="comment">// 归一化</span></span><br><span class="line">D2.convertTo(D2, CV_8UC3);</span><br><span class="line">cv::imshow(<span class="string">"Detail layer 2"</span>, D2);</span><br><span class="line"></span><br><span class="line">cv::waitKey();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/two-ways-of-extracting-detail-of-image-im.png" alt="图1：源图像" title="">                </div>                <div class="image-caption">图1：源图像</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/two-ways-of-extracting-detail-of-image-B.png" alt="图2：Base Layer" title="">                </div>                <div class="image-caption">图2：Base Layer</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/two-ways-of-extracting-detail-of-image-D1.png" alt="图3：Detail Layer1" title="">                </div>                <div class="image-caption">图3：Detail Layer1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/two-ways-of-extracting-detail-of-image-D2.png" alt="图4：Detail Layer2" title="">                </div>                <div class="image-caption">图4：Detail Layer2</div>            </figure><h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h2><p>提取图像的细节层后，可以进行细节增强(detail enhancement)或细节转移(detail transfer)[2]等。</p><h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><p>[1] S. Li, X. Kang, and J. Hu. Image fusion with guided fltering. IEEE Transactions on Image Processing, 22(7):2864–2875, July 2013.</p><p>[2] Georg Petschnigg, Richard Szeliski, Maneesh Agrawala, Michael Cohen, Hugues Hoppe, and Kentaro Toyama. Digital photography with ﬂash and no-ﬂash image pairs. In ACM transactions on graphics (TOG), volume 23, pages 664–672. ACM, 2004.</p><p>[3] Amnon Shashua and Tammy Riklin-Raviv. The quotient image: Class-based re-rendering and recognition with varying illuminations. IEEE Transactions on Pattern Analysis and Machine Intelligence, 23(2):129–139, 2001.</p><p>[4] Zicheng Liu, Ying Shan, and Zhengyou Zhang. Expressive expression mapping with ratio images. In Proceedings of the 28th annual conference on Computer graphics and interactive techniques, pages 271–276. ACM, 2001.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一幅图像可以分解为两层：底层(base layer)和细节层(detail layer)。底层包含图像的低频信息，反映了图像在大尺度上的强度变化；细节层包含图像的高频信息，反映了图像在小尺度上的细节。分解图像有两种方式，以下分别进行解释。&lt;/p&gt;
&lt;h2 id=&quot;1-加性分
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="image-processing" scheme="http://yoursite.com/tags/image-processing/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/04/28/hello-world/"/>
    <id>http://yoursite.com/2018/04/28/hello-world/</id>
    <published>2018-04-28T15:23:59.783Z</published>
    <updated>2018-04-28T14:34:14.543Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
</feed>
