<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天律界</title>
  
  <subtitle>精诚所至，金石为开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-05T15:07:31.163Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>天律界中子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11高精度计时器</title>
    <link href="http://yoursite.com/2018/06/05/cpp-timer/"/>
    <id>http://yoursite.com/2018/06/05/cpp-timer/</id>
    <published>2018-06-05T14:26:41.000Z</published>
    <updated>2018-06-05T15:07:31.163Z</updated>
    
    <content type="html"><![CDATA[<p>做图像处理算法时，免不了要测量函数的运行时间。以前我都是使用OpenCV的计时函数<code>cv::getTickCount()</code>和<code>cv::getTickFrequency()</code>，但是这样一来，在不使用OpenCV的项目中就没法用了。幸好C++11增加了<code>std::chrono</code>库，可以很方便地实现跨平台的时间测量。于是我封装了一个简单的计时器类，这样只要将其简单地添加到项目中，就可以直接使用了。此计时器单位为毫秒，但可以精确到微秒级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Timer()</span><br><span class="line">: t1(res::zero())</span><br><span class="line">, t2(res::zero())</span><br><span class="line">&#123;</span><br><span class="line">tic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Timer()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t1 = clock::now();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t2 = clock::now();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">" time: "</span> </span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;res&gt;(t2 - t1).count() / <span class="number">1e3</span> &lt;&lt; <span class="string">"ms."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::high_resolution_clock clock;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::microseconds res;</span><br><span class="line"></span><br><span class="line">clock::time_point t1;</span><br><span class="line">clock::time_point t2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Timer timer;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">timer.toc(<span class="string">"output 1"</span>);</span><br><span class="line"></span><br><span class="line">timer.tic();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">timer.toc(<span class="string">"output 2"</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">output <span class="number">1</span> time: <span class="number">0.26</span>ms.</span><br><span class="line"><span class="number">2</span></span><br><span class="line">output <span class="number">2</span> time: <span class="number">0.039</span>ms.</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做图像处理算法时，免不了要测量函数的运行时间。以前我都是使用OpenCV的计时函数&lt;code&gt;cv::getTickCount()&lt;/code&gt;和&lt;code&gt;cv::getTickFrequency()&lt;/code&gt;，但是这样一来，在不使用OpenCV的项目中就没法用了。幸
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>提取图像细节的两种方法</title>
    <link href="http://yoursite.com/2018/04/29/two-ways-of-extracting-detail-of-image/"/>
    <id>http://yoursite.com/2018/04/29/two-ways-of-extracting-detail-of-image/</id>
    <published>2018-04-29T13:50:14.000Z</published>
    <updated>2018-06-05T15:25:29.169Z</updated>
    
    <content type="html"><![CDATA[<p>一幅图像可以分解为两层：底层(base layer)和细节层(detail layer)。底层包含图像的低频信息，反映了图像在大尺度上的强度变化；细节层包含图像的高频信息，反映了图像在小尺度上的细节。分解图像有两种方式，以下分别进行解释。</p><h2 id="1-加性分解"><a href="#1-加性分解" class="headerlink" title="1. 加性分解"></a>1. 加性分解</h2><p>要获取图像的底层，即图像的低频信息，使用低通滤波(如均值滤波(mean filter)，高斯滤波(gaussian filter)，导向滤波(guided filter))对图像进行滤波即可：<br>$$B = f(I) $$<br>其中$I$表示要分解的图像，$f(\cdot)$表示低通滤波操作，$B$为提取的底层。</p><p>提取底层后，使用源图像减去底层，即为细节层：<br>$$D = I - B$$<br>其中$D$表示提取的细节层。</p><p>因为底层加上细节层即为源图像，所以我称此种分解方法为加性分解，对应于加性噪声。关于此种方法的应用，可以参见[1]。</p><h2 id="2-乘性分解"><a href="#2-乘性分解" class="headerlink" title="2. 乘性分解"></a>2. 乘性分解</h2><p>获取底层的方法与<strong>加性分解</strong>相同。然后使用源图像除以底层，即可得到细节层：<br>$$D = \frac{I + \epsilon}{B + \epsilon}$$<br>其中$\epsilon$为一个很小的常数，以防止除零错误。</p><p>因为底层乘以细节层即为源图像，所以我称此种分解方法为乘性分解，对应于乘性噪声。关于此种方法的应用，可以参见[2]。在其他文章中，此处得到的细节层也称为商图像(quotient image)[3]或比例图像(ratio image)[4]。</p><h2 id="3-代码及效果"><a href="#3-代码及效果" class="headerlink" title="3. 代码及效果"></a>3. 代码及效果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图像细节提取。</span></span><br><span class="line"><span class="comment">// 编程环境：Visual Studio Community 2015 + OpenCV 3.3.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat I = cv::imread(<span class="string">"im.png"</span>);</span><br><span class="line"><span class="keyword">if</span> (I.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">I.convertTo(I, CV_32FC3);</span><br><span class="line"></span><br><span class="line">cv::Mat B;</span><br><span class="line">cv::boxFilter(I, B, <span class="number">-1</span>, cv::Size(<span class="number">31</span>, <span class="number">31</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 加性分解</span></span><br><span class="line">cv::Mat D1 = I - B;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 乘性分解</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> epsilon = <span class="number">1.0f</span>;</span><br><span class="line">cv::Mat D2 = (I + epsilon) / (B + epsilon);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示图像</span></span><br><span class="line">I.convertTo(I, CV_8UC3);</span><br><span class="line">cv::imshow(<span class="string">"源图像"</span>, I);</span><br><span class="line"></span><br><span class="line">B.convertTo(B, CV_8UC3);</span><br><span class="line">cv::imshow(<span class="string">"Base layer"</span>, B);</span><br><span class="line"></span><br><span class="line">D1 = cv::<span class="built_in">abs</span>(D1); <span class="comment">// 因为包含负数，所以取绝对值</span></span><br><span class="line">D1.convertTo(D1, CV_8UC3);</span><br><span class="line">cv::imshow(<span class="string">"Detail layer 1"</span>, D1);</span><br><span class="line"></span><br><span class="line">cv::normalize(D2, D2, <span class="number">0.0</span>, <span class="number">255.0</span>, cv::NORM_MINMAX); <span class="comment">// 归一化</span></span><br><span class="line">D2.convertTo(D2, CV_8UC3);</span><br><span class="line">cv::imshow(<span class="string">"Detail layer 2"</span>, D2);</span><br><span class="line"></span><br><span class="line">cv::waitKey();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/two-ways-of-extracting-detail-of-image-im.png" alt="图1：源图像" title="">                </div>                <div class="image-caption">图1：源图像</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/two-ways-of-extracting-detail-of-image-B.png" alt="图2：Base Layer" title="">                </div>                <div class="image-caption">图2：Base Layer</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/two-ways-of-extracting-detail-of-image-D1.png" alt="图3：Detail Layer1" title="">                </div>                <div class="image-caption">图3：Detail Layer1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://o96d382wn.bkt.clouddn.com/two-ways-of-extracting-detail-of-image-D2.png" alt="图4：Detail Layer2" title="">                </div>                <div class="image-caption">图4：Detail Layer2</div>            </figure><h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h2><p>提取图像的细节层后，可以进行细节增强(detail enhancement)或细节转移(detail transfer)[2]等。</p><h2 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h2><p>[1] S. Li, X. Kang, and J. Hu. Image fusion with guided fltering. IEEE Transactions on Image Processing, 22(7):2864–2875, July 2013.</p><p>[2] Georg Petschnigg, Richard Szeliski, Maneesh Agrawala, Michael Cohen, Hugues Hoppe, and Kentaro Toyama. Digital photography with ﬂash and no-ﬂash image pairs. In ACM transactions on graphics (TOG), volume 23, pages 664–672. ACM, 2004.</p><p>[3] Amnon Shashua and Tammy Riklin-Raviv. The quotient image: Class-based re-rendering and recognition with varying illuminations. IEEE Transactions on Pattern Analysis and Machine Intelligence, 23(2):129–139, 2001.</p><p>[4] Zicheng Liu, Ying Shan, and Zhengyou Zhang. Expressive expression mapping with ratio images. In Proceedings of the 28th annual conference on Computer graphics and interactive techniques, pages 271–276. ACM, 2001.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一幅图像可以分解为两层：底层(base layer)和细节层(detail layer)。底层包含图像的低频信息，反映了图像在大尺度上的强度变化；细节层包含图像的高频信息，反映了图像在小尺度上的细节。分解图像有两种方式，以下分别进行解释。&lt;/p&gt;
&lt;h2 id=&quot;1-加性分
      
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="image-processing" scheme="http://yoursite.com/tags/image-processing/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/04/28/hello-world/"/>
    <id>http://yoursite.com/2018/04/28/hello-world/</id>
    <published>2018-04-28T15:23:59.783Z</published>
    <updated>2018-04-28T14:34:14.543Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
</feed>
